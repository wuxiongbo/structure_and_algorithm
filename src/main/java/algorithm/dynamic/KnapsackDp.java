package src.main.java.algorithm.dynamic;

/**
 * 动态规划  dynamic programming
 * 背包问题  Knapsack /ˈnæp,sæk/
 */
public class KnapsackDp {

	public static void main(String[] args) {
		//           物品 1,  2, 3
		int value [] = { 60,100,120};  //￥
		int weight[] = { 10,20 ,40 };  //kg  购物车问题，只需要一个价值就行了，重量都都没有。
		
		int w = 50;  //kg 背包容量
		int n = 3;   //物品种类

        //[0,50] 51个元素。[0,3] 4个元素。所以要n+1、w+1
        //n表示物品，w表示重量; 初始化全是0
		int [][] totalValue = new int[n+1][w+1];
                                         //int [][] totalValue，两个维度的索引，均从1开始。
                                         // 如：totalValue[1][cw]  表示物品1  cw分割容量下的价值
                                         //    value[0]    表示物品1 的价值
                                         //    weight[0]   表示物品1 的重量

		for(int i = 1; i<= n; i++){	 //i 表示当前加的物品
			for(int cw = 1 ; cw <= w ; cw ++){	//cw 背包分割容量
				if(weight[i - 1] <= cw){		//当前物品重量 <= 背包容量。可装
                    totalValue[i][cw] = Math.max(
                            //当前物品价值 + 上个物品加入时(上个表行)，剩余分割容量的最大价值(当前分割容量-当前物品重量)。
							value[i-1] + totalValue[i-1][cw-weight[i-1]],
                            //上个物品加入时(上个表行)，当前分割容量的最大价值。
                            totalValue[i-1][cw]
							);
				}else{ //当前物品重量 > 背包容量。不可装
                    //上个物品加入后，当前分割容量的最大值。
                    // (当前物品不可装，延续 上个物品装入后 相同分割容量下的最大价值)
                    totalValue[i][cw] = totalValue[i-1][cw];
				}
			}
		}
		System.out.println(totalValue[n][w]);

		//怎么查找，加入了哪些物品呢？
        for (int i = 0; i <=n ; i++) {
            for (int cw = 0; cw < w; cw++) {
                System.out.printf("%-4s", totalValue[i][cw]);
            }
            System.out.println();
        }
        /*
----0-1-----------------10-------------------------20-------------------------------------30--------------------------------------40---------------------------------------50--
0 - 0 0 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0    0
1 - 0 0 0 0 0 0 0 0 0 0 60 60 60 60 60 60 60 60 60 60 60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  60  /60/
2 - 0 0 0 0 0 0 0 0 0 0 60 60 60 60 60 60 60 60 60 60 100 100 100 100 100 100 100 100 100 100 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 /160/
3 - 0 0 0 0 0 0 0 0 0 0 60 60 60 60 60 60 60 60 60 60 100 100 100 100 100 100 100 100 100 100 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 /160/
         只需要关注最后一列，逐行 倒着往上推：相等 则 加了该物品、不相等 则 没加该物品。
        *
        * */
        int tValue = totalValue[n][w]; //最后一行，最后一列。能装的最大价值。
        System.out.println("最大价值："+tValue+"￥");
        for (int i = n; i > 0; i--) {
            if(totalValue[i][w] != totalValue[i-1][w]){
                System.out.println("物品"+i+"："+weight[i - 1]+"kg");
                w -= weight[i - 1]; //减去当前物品后，的分割容量
            }
        }

	}
}
